# Optimising Compiler

Assume you have a compiler for BF that produces binaries using proper
branches, rather than tracing the program with an instruction pointer.

It would be quite possible to write an optimising compiler for
BF from it. Here are the obvious optimisations I can see.

(Whilst some optimisations here are trivial, many BF programs are at
least partly autogenerated, making even things like 'removing
redundant operations' worthwhile.)

## Constant propagation

In the following program:

    +>+>
    [more stuff]

The first line is executed unconditionally. Normally,  you'd set up
30,000 cells initialised to zero and execute the first line. Instead,
you could evaluate the first line at compile time, and initialise the
cells to the result.

You could actually take this further, even evaluating `[]` sections if
they perform no IO.

(IR transformation, speed improvement.)

## Move/Copy detection

It's very common to copy values between cells. A program of the form:

    [>+>+<<.] Copy cell #0 to cell #1 and #2, zeroing #0

Rather than a naive IR equivalent, IR should look like this:

    cells[index+1] = cells[index]
    cells[index+2] = cells[index]
    cells[index] = 0

(IR transformation, speed improvement.)
