# Optimising Compiler

Assume you have a compiler for BF that produces binaries using proper
branches, rather than tracing the program with an instruction pointer.

It would be quite possible to write an optimising compiler for
BF from it. Here are the obvious optimisations I can see.

(Whilst some optimisations here are trivial, many BF programs are at
least partly autogenerated, making even things like 'removing
redundant operations' worthwhile.)

## Dead code elimination

It's common to see programs of the form:

    [All about this program.,+-]
    ,.

The first line of the program will never executed.

(Source-to source transformation, speed improvement.)

Likewise, if a loop is followed by another loop, that loop is dead.

Any non-loop instructions that aren't followed by output instructions
are dead.

## Constant propagation

In the following program:

    +>+>
    [more stuff]

The first line is executed unconditionally. Normally,  you'd set up
30,000 cells initialised to zero and execute the first line. Instead,
you could evaluate the first line at compile time, and initialise the
cells to the result.

You could actually take this further, even evaluating `[]` sections if
they perform no IO.

(IR transformation, speed improvement.)

## Move/Copy detection

It's very common to copy values between cells. A program of the form:

    [>+>+<<.] Copy cell #0 to cell #1 and #2, zeroing #0

Rather than a naive IR equivalent, IR should look like this:

    cells[index+1] = cells[index]
    cells[index+2] = cells[index]
    cells[index] = 0

(IR transformation, speed improvement.)

## Cell counting

Most BF programs don't use an unbounded number of cells, and some
interpreters only provide 30,000 cells. If we consider every possible
path through the conditionals, and the net number of cell moves, we do
not need to allocate 30,000 cells to our compiled program.

Examples:

1: Unbounded cell usage, no optimisation possible: `[>]`

2: `[><]` visits cell #1, but this conditional produces a net movement
of 0.

(IR transsformation, memory improvement.)

## Constant cell detection

If, after constant propagation, we can demonstrate that a cell is
never modified, we can replace accesses to it with its constant value.

So if cell #5 never changes from the value 21, we can replace all IR
of the form:

    cell[index] = cell[5]

with:

    cell[index] = 21

Depending on how sophisticated our cell counting can be, we may also be
able to remove cell #5 entirely, so cell #6 is stored in its place.
    
(IR transformation, speed and potentially memory improvement.)
